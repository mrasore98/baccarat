{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome! So you want to run a Monte Carlo simulation? Then you're in the right place! Baccarat is an easy-to-use framework that makes running Monte Carlo simulations a breeze. To get started, head over to the Quick Start Guide or check out the Tutorials .","title":"Home"},{"location":"#welcome","text":"","title":"Welcome!"},{"location":"#so-you-want-to-run-a-monte-carlo-simulation","text":"Then you're in the right place! Baccarat is an easy-to-use framework that makes running Monte Carlo simulations a breeze. To get started, head over to the Quick Start Guide or check out the Tutorials .","title":"So you want to run a Monte Carlo simulation?"},{"location":"quickstart/","text":"Quick Start Guide Installation To get started with baccarat, you can install it using pip (or uv or poetry or your package manager of choice): pip install baccarat Usage A simple example using baccarat to approximate pi: from baccarat import Simulator, UniformParam, StaticParam class PiSimulator(Simulator): radius = 1 # These parameters are descriptors, used to generate random values when accessed x = UniformParam(-radius, radius) y = UniformParam(-radius, radius) # Strictly speaking, this could be a constant, but we use a Param for consistency r = StaticParam(radius) def simulation(self): # Use assignments since attribute access will generate the random value x, y, r = self.x, self.y, self.r # Check to see if the random point is inside the circle return x**2 + y**2 <= r**2 def compile_results(self): return 4 * len([res for res in self.results if res]) / len(self.results) approx_pi = PiSimulator(1_000_000).run() Notes: All user simulations start with a class that inherits from Simulator and implements the simulation method. The simulation method defines the vectorized logic for the simulation. It should return a NumPy array of results. Optionally, the compile_results method can be implemented to process the results array once the simulation is complete. Parameters are defined as class attributes. Distributions for generating random values are specified using the concrete implementations of the Param class, such as UniformParam and GaussianParam . When accessed, parameters return NumPy arrays containing the random values, enabling efficient vectorized operations. Custom distributions can be created by subclassing the Param class and implementing the generate method to return a NumPy array. The number of samples used in the simulation are specified when creating an instance of the Simulator subclass. Examples For more examples, see the examples on GitHub.","title":"Quick Start"},{"location":"quickstart/#quick-start-guide","text":"","title":"Quick Start Guide"},{"location":"quickstart/#installation","text":"To get started with baccarat, you can install it using pip (or uv or poetry or your package manager of choice): pip install baccarat","title":"Installation"},{"location":"quickstart/#usage","text":"A simple example using baccarat to approximate pi: from baccarat import Simulator, UniformParam, StaticParam class PiSimulator(Simulator): radius = 1 # These parameters are descriptors, used to generate random values when accessed x = UniformParam(-radius, radius) y = UniformParam(-radius, radius) # Strictly speaking, this could be a constant, but we use a Param for consistency r = StaticParam(radius) def simulation(self): # Use assignments since attribute access will generate the random value x, y, r = self.x, self.y, self.r # Check to see if the random point is inside the circle return x**2 + y**2 <= r**2 def compile_results(self): return 4 * len([res for res in self.results if res]) / len(self.results) approx_pi = PiSimulator(1_000_000).run() Notes: All user simulations start with a class that inherits from Simulator and implements the simulation method. The simulation method defines the vectorized logic for the simulation. It should return a NumPy array of results. Optionally, the compile_results method can be implemented to process the results array once the simulation is complete. Parameters are defined as class attributes. Distributions for generating random values are specified using the concrete implementations of the Param class, such as UniformParam and GaussianParam . When accessed, parameters return NumPy arrays containing the random values, enabling efficient vectorized operations. Custom distributions can be created by subclassing the Param class and implementing the generate method to return a NumPy array. The number of samples used in the simulation are specified when creating an instance of the Simulator subclass.","title":"Usage"},{"location":"quickstart/#examples","text":"For more examples, see the examples on GitHub.","title":"Examples"},{"location":"api/","text":"API Reference This section provides detailed documentation for the Baccarat API. Overview Baccarat is a framework for running Monte Carlo simulations using NumPy. It provides: A base Simulator class for implementing custom simulations Parameter descriptors that generate random values according to specific distributions Vectorized operations for high performance Module Structure simulator : Contains the Simulator base class params : Contains parameter descriptor classes for simulations params.base : Base parameter class params.gaussian : Gaussian distribution parameters params.uniform : Uniform distribution parameters params.static : Static (fixed) parameters","title":"Overview"},{"location":"api/#api-reference","text":"This section provides detailed documentation for the Baccarat API.","title":"API Reference"},{"location":"api/#overview","text":"Baccarat is a framework for running Monte Carlo simulations using NumPy. It provides: A base Simulator class for implementing custom simulations Parameter descriptors that generate random values according to specific distributions Vectorized operations for high performance","title":"Overview"},{"location":"api/#module-structure","text":"simulator : Contains the Simulator base class params : Contains parameter descriptor classes for simulations params.base : Base parameter class params.gaussian : Gaussian distribution parameters params.uniform : Uniform distribution parameters params.static : Static (fixed) parameters","title":"Module Structure"},{"location":"api/simulator/","text":"Simulator baccarat.simulator.Simulator Overview The Simulator class is the core of the Baccarat framework. It provides the foundation for implementing Monte Carlo simulations with vectorized operations via NumPy. Class Definition class Simulator(ABC): def __init__(self, num_samples: int): \"\"\" Initialize a simulator for Monte Carlo simulations. Args: num_samples: Number of simulation samples to generate \"\"\" Methods simulation @abstractmethod def simulation(self): \"\"\" Logic for a single simulation. This method must be implemented by subclasses and contains the core simulation logic. The method should return a NumPy array of results. Returns: np.ndarray: Array of simulation results \"\"\" compile_results def compile_results(self) -> Any: \"\"\" Compile the results of the simulations. Post-processing of the results after all simulations have been completed. By default, this method simply returns the results array. Returns: Any: Processed simulation results \"\"\" run def run(self): \"\"\" Main entry point to execute the simulation. Runs the simulation and compiles the results. Returns: Any: The compiled simulation results \"\"\" Properties num_samples : Number of simulation samples results : NumPy array storing simulation results rng : NumPy random number generator Usage To create a custom simulation, subclass Simulator and implement the simulation method: import numpy as np from baccarat import Simulator, UniformParam class PiEstimator(Simulator): x = UniformParam(-1.0, 1.0) y = UniformParam(-1.0, 1.0) def simulation(self): # Get random points in a square x = self.x y = self.y # Check if points are inside the unit circle inside_circle = x**2 + y**2 <= 1.0 # Return array of boolean values (inside circle = True) return inside_circle def compile_results(self): # Calculate pi estimation: (points inside circle / total points) * 4 return 4.0 * np.mean(self.results) # Create and run simulation simulator = PiEstimator(num_samples=1000000) pi_estimate = simulator.run() print(f\"Pi estimate: {pi_estimate}\")","title":"Simulator"},{"location":"api/simulator/#simulator","text":"baccarat.simulator.Simulator","title":"Simulator"},{"location":"api/simulator/#overview","text":"The Simulator class is the core of the Baccarat framework. It provides the foundation for implementing Monte Carlo simulations with vectorized operations via NumPy.","title":"Overview"},{"location":"api/simulator/#class-definition","text":"class Simulator(ABC): def __init__(self, num_samples: int): \"\"\" Initialize a simulator for Monte Carlo simulations. Args: num_samples: Number of simulation samples to generate \"\"\"","title":"Class Definition"},{"location":"api/simulator/#methods","text":"","title":"Methods"},{"location":"api/simulator/#simulation","text":"@abstractmethod def simulation(self): \"\"\" Logic for a single simulation. This method must be implemented by subclasses and contains the core simulation logic. The method should return a NumPy array of results. Returns: np.ndarray: Array of simulation results \"\"\"","title":"simulation"},{"location":"api/simulator/#compile_results","text":"def compile_results(self) -> Any: \"\"\" Compile the results of the simulations. Post-processing of the results after all simulations have been completed. By default, this method simply returns the results array. Returns: Any: Processed simulation results \"\"\"","title":"compile_results"},{"location":"api/simulator/#run","text":"def run(self): \"\"\" Main entry point to execute the simulation. Runs the simulation and compiles the results. Returns: Any: The compiled simulation results \"\"\"","title":"run"},{"location":"api/simulator/#properties","text":"num_samples : Number of simulation samples results : NumPy array storing simulation results rng : NumPy random number generator","title":"Properties"},{"location":"api/simulator/#usage","text":"To create a custom simulation, subclass Simulator and implement the simulation method: import numpy as np from baccarat import Simulator, UniformParam class PiEstimator(Simulator): x = UniformParam(-1.0, 1.0) y = UniformParam(-1.0, 1.0) def simulation(self): # Get random points in a square x = self.x y = self.y # Check if points are inside the unit circle inside_circle = x**2 + y**2 <= 1.0 # Return array of boolean values (inside circle = True) return inside_circle def compile_results(self): # Calculate pi estimation: (points inside circle / total points) * 4 return 4.0 * np.mean(self.results) # Create and run simulation simulator = PiEstimator(num_samples=1000000) pi_estimate = simulator.run() print(f\"Pi estimate: {pi_estimate}\")","title":"Usage"},{"location":"api/params/","text":"Parameters baccarat.params Overview The params module provides parameter descriptor classes for use with the Simulator class. These parameters automatically generate random values according to specific distributions when accessed within a simulation. Base Class All parameter types inherit from the Param abstract base class, which defines the common interface. Parameter Types Class Description GaussianParam Generates random values from a Gaussian (normal) distribution UniformParam Generates random values from a uniform distribution StaticParam Provides a fixed, constant value Usage Parameters are defined as class variables in a Simulator subclass: from baccarat import Simulator, GaussianParam, UniformParam, StaticParam class MySimulator(Simulator): # Parameters are defined as class variables x = UniformParam(0.0, 10.0) y = GaussianParam(mean=5.0, std=2.0) z = StaticParam(3.14159) def simulation(self): # Access parameters to get arrays of random values x_values = self.x # Array of uniform random values y_values = self.y # Array of gaussian random values z_values = self.z # Array filled with the constant value # Perform calculations with these arrays result = x_values * y_values + z_values return result The parameters use Python's descriptor protocol to generate new random values each time they are accessed.","title":"Overview"},{"location":"api/params/#parameters","text":"baccarat.params","title":"Parameters"},{"location":"api/params/#overview","text":"The params module provides parameter descriptor classes for use with the Simulator class. These parameters automatically generate random values according to specific distributions when accessed within a simulation.","title":"Overview"},{"location":"api/params/#base-class","text":"All parameter types inherit from the Param abstract base class, which defines the common interface.","title":"Base Class"},{"location":"api/params/#parameter-types","text":"Class Description GaussianParam Generates random values from a Gaussian (normal) distribution UniformParam Generates random values from a uniform distribution StaticParam Provides a fixed, constant value","title":"Parameter Types"},{"location":"api/params/#usage","text":"Parameters are defined as class variables in a Simulator subclass: from baccarat import Simulator, GaussianParam, UniformParam, StaticParam class MySimulator(Simulator): # Parameters are defined as class variables x = UniformParam(0.0, 10.0) y = GaussianParam(mean=5.0, std=2.0) z = StaticParam(3.14159) def simulation(self): # Access parameters to get arrays of random values x_values = self.x # Array of uniform random values y_values = self.y # Array of gaussian random values z_values = self.z # Array filled with the constant value # Perform calculations with these arrays result = x_values * y_values + z_values return result The parameters use Python's descriptor protocol to generate new random values each time they are accessed.","title":"Usage"},{"location":"api/params/base/","text":"Base Parameter baccarat.params.Param Overview The Param class is an abstract base class that defines the interface for all parameter types. It implements Python's descriptor protocol to automatically generate new random values when accessed within a Simulator instance. Class Definition class Param(ABC): def __get__(self, instance, owner): # Generate a new value each time the parameter is accessed return self.generate(rng=instance.rng, num_generated=instance.num_samples) @abstractmethod def generate(self, rng: np.random.Generator, num_generated: int) -> np.ndarray: \"\"\" Generate random values using the given random number generator. Args: rng: The NumPy random number generator to use num_generated: Number of values to generate Returns: np.ndarray: Array of generated values \"\"\" Descriptor Protocol The Param class uses Python's descriptor protocol to provide dynamic behavior when parameters are accessed as instance attributes in a Simulator subclass: When a parameter is accessed (e.g., self.x in a Simulator subclass), Python calls the __get__ method The __get__ method calls the generate method with the simulator's random number generator and sample count The generate method returns an array of random values according to the parameter's specific distribution Custom Parameter Types To create a custom parameter type, subclass Param and implement the generate method: import numpy as np from baccarat.params import Param class ExponentialParam(Param): def __init__(self, scale=1.0): self.scale = scale def generate(self, rng: np.random.Generator, num_generated: int) -> np.ndarray: return rng.exponential(scale=self.scale, size=num_generated)","title":"Base Parameter"},{"location":"api/params/base/#base-parameter","text":"baccarat.params.Param","title":"Base Parameter"},{"location":"api/params/base/#overview","text":"The Param class is an abstract base class that defines the interface for all parameter types. It implements Python's descriptor protocol to automatically generate new random values when accessed within a Simulator instance.","title":"Overview"},{"location":"api/params/base/#class-definition","text":"class Param(ABC): def __get__(self, instance, owner): # Generate a new value each time the parameter is accessed return self.generate(rng=instance.rng, num_generated=instance.num_samples) @abstractmethod def generate(self, rng: np.random.Generator, num_generated: int) -> np.ndarray: \"\"\" Generate random values using the given random number generator. Args: rng: The NumPy random number generator to use num_generated: Number of values to generate Returns: np.ndarray: Array of generated values \"\"\"","title":"Class Definition"},{"location":"api/params/base/#descriptor-protocol","text":"The Param class uses Python's descriptor protocol to provide dynamic behavior when parameters are accessed as instance attributes in a Simulator subclass: When a parameter is accessed (e.g., self.x in a Simulator subclass), Python calls the __get__ method The __get__ method calls the generate method with the simulator's random number generator and sample count The generate method returns an array of random values according to the parameter's specific distribution","title":"Descriptor Protocol"},{"location":"api/params/base/#custom-parameter-types","text":"To create a custom parameter type, subclass Param and implement the generate method: import numpy as np from baccarat.params import Param class ExponentialParam(Param): def __init__(self, scale=1.0): self.scale = scale def generate(self, rng: np.random.Generator, num_generated: int) -> np.ndarray: return rng.exponential(scale=self.scale, size=num_generated)","title":"Custom Parameter Types"},{"location":"api/params/gaussian/","text":"Gaussian Parameter baccarat.params.GaussianParam Overview The GaussianParam class generates random values from a Gaussian (normal) distribution. It is a concrete implementation of the Param abstract base class. Class Definition class GaussianParam(Param): def __init__(self, mean: float, std: float): \"\"\" Initialize a Gaussian parameter. Args: mean: The mean (average) of the distribution std: The standard deviation of the distribution \"\"\" self.mean = mean self.std = std def generate(self, rng: np.random.Generator, num_generated: int) -> np.ndarray: \"\"\" Generate random values from a Gaussian distribution. Args: rng: The NumPy random number generator to use num_generated: Number of values to generate Returns: np.ndarray: Array of random values from the Gaussian distribution \"\"\" return rng.normal(self.mean, self.std, size=num_generated) Usage from baccarat import Simulator, GaussianParam class MySimulator(Simulator): # Create a Gaussian parameter with mean 0 and standard deviation 1 x = GaussianParam(mean=0.0, std=1.0) def simulation(self): # Access the parameter to get an array of gaussian random values values = self.x # Perform calculations with these values return values ** 2","title":"Gaussian Parameter"},{"location":"api/params/gaussian/#gaussian-parameter","text":"baccarat.params.GaussianParam","title":"Gaussian Parameter"},{"location":"api/params/gaussian/#overview","text":"The GaussianParam class generates random values from a Gaussian (normal) distribution. It is a concrete implementation of the Param abstract base class.","title":"Overview"},{"location":"api/params/gaussian/#class-definition","text":"class GaussianParam(Param): def __init__(self, mean: float, std: float): \"\"\" Initialize a Gaussian parameter. Args: mean: The mean (average) of the distribution std: The standard deviation of the distribution \"\"\" self.mean = mean self.std = std def generate(self, rng: np.random.Generator, num_generated: int) -> np.ndarray: \"\"\" Generate random values from a Gaussian distribution. Args: rng: The NumPy random number generator to use num_generated: Number of values to generate Returns: np.ndarray: Array of random values from the Gaussian distribution \"\"\" return rng.normal(self.mean, self.std, size=num_generated)","title":"Class Definition"},{"location":"api/params/gaussian/#usage","text":"from baccarat import Simulator, GaussianParam class MySimulator(Simulator): # Create a Gaussian parameter with mean 0 and standard deviation 1 x = GaussianParam(mean=0.0, std=1.0) def simulation(self): # Access the parameter to get an array of gaussian random values values = self.x # Perform calculations with these values return values ** 2","title":"Usage"},{"location":"api/params/static/","text":"Static Parameter baccarat.params.StaticParam Overview The StaticParam class provides a fixed, constant value as an array. It is a concrete implementation of the Param abstract base class. Class Definition class StaticParam(Param): def __init__(self, value): \"\"\" Initialize a static parameter. Args: value: The fixed value to use for all elements \"\"\" self.value = value def generate(self, rng: np.random.Generator, num_generated: int) -> np.ndarray: \"\"\" Generate an array filled with the constant value. Args: rng: The NumPy random number generator (not used) num_generated: Number of elements in the array Returns: np.ndarray: Array filled with the constant value \"\"\" return self.value * np.ones(num_generated) Usage from baccarat import Simulator, UniformParam, StaticParam class GravitySimulator(Simulator): # Random initial height (0-100 meters) height = UniformParam(0.0, 100.0) # Constant gravitational acceleration (9.81 m/s\u00b2) gravity = StaticParam(9.81) def simulation(self): # Calculate time to hit ground: t = sqrt(2h/g) heights = self.height g = self.gravity # Return array of fall times return np.sqrt(2 * heights / g) Notes The StaticParam creates an array where every element has the same value Unlike other parameter types, it does not use the random number generator Useful for physical constants or other fixed values in simulations","title":"Static Parameter"},{"location":"api/params/static/#static-parameter","text":"baccarat.params.StaticParam","title":"Static Parameter"},{"location":"api/params/static/#overview","text":"The StaticParam class provides a fixed, constant value as an array. It is a concrete implementation of the Param abstract base class.","title":"Overview"},{"location":"api/params/static/#class-definition","text":"class StaticParam(Param): def __init__(self, value): \"\"\" Initialize a static parameter. Args: value: The fixed value to use for all elements \"\"\" self.value = value def generate(self, rng: np.random.Generator, num_generated: int) -> np.ndarray: \"\"\" Generate an array filled with the constant value. Args: rng: The NumPy random number generator (not used) num_generated: Number of elements in the array Returns: np.ndarray: Array filled with the constant value \"\"\" return self.value * np.ones(num_generated)","title":"Class Definition"},{"location":"api/params/static/#usage","text":"from baccarat import Simulator, UniformParam, StaticParam class GravitySimulator(Simulator): # Random initial height (0-100 meters) height = UniformParam(0.0, 100.0) # Constant gravitational acceleration (9.81 m/s\u00b2) gravity = StaticParam(9.81) def simulation(self): # Calculate time to hit ground: t = sqrt(2h/g) heights = self.height g = self.gravity # Return array of fall times return np.sqrt(2 * heights / g)","title":"Usage"},{"location":"api/params/static/#notes","text":"The StaticParam creates an array where every element has the same value Unlike other parameter types, it does not use the random number generator Useful for physical constants or other fixed values in simulations","title":"Notes"},{"location":"api/params/uniform/","text":"Uniform Parameter baccarat.params.UniformParam Overview The UniformParam class generates random values from a uniform distribution. It is a concrete implementation of the Param abstract base class. Class Definition class UniformParam(Param): def __init__(self, low: float = 0.0, high: float = 1.0): \"\"\" Initialize a uniform parameter. Args: low: Lower bound of the distribution (inclusive) high: Upper bound of the distribution (exclusive) \"\"\" self.low = low self.high = high def generate(self, rng: np.random.Generator, num_generated: int) -> np.ndarray: \"\"\" Generate random values from a uniform distribution. Args: rng: The NumPy random number generator to use num_generated: Number of values to generate Returns: np.ndarray: Array of random values from the uniform distribution \"\"\" return rng.uniform(self.low, self.high, size=num_generated) Usage from baccarat import Simulator, UniformParam class DiceRollSimulator(Simulator): # Create a uniform parameter for dice rolls (1-6) # Note: We use 0.5 to 6.5 to get a uniform distribution over integers 1-6 roll = UniformParam(low=0.5, high=6.5) def simulation(self): # Get array of random dice rolls rolls = self.roll # Convert to integers (1-6) return np.floor(rolls).astype(int)","title":"Uniform Parameter"},{"location":"api/params/uniform/#uniform-parameter","text":"baccarat.params.UniformParam","title":"Uniform Parameter"},{"location":"api/params/uniform/#overview","text":"The UniformParam class generates random values from a uniform distribution. It is a concrete implementation of the Param abstract base class.","title":"Overview"},{"location":"api/params/uniform/#class-definition","text":"class UniformParam(Param): def __init__(self, low: float = 0.0, high: float = 1.0): \"\"\" Initialize a uniform parameter. Args: low: Lower bound of the distribution (inclusive) high: Upper bound of the distribution (exclusive) \"\"\" self.low = low self.high = high def generate(self, rng: np.random.Generator, num_generated: int) -> np.ndarray: \"\"\" Generate random values from a uniform distribution. Args: rng: The NumPy random number generator to use num_generated: Number of values to generate Returns: np.ndarray: Array of random values from the uniform distribution \"\"\" return rng.uniform(self.low, self.high, size=num_generated)","title":"Class Definition"},{"location":"api/params/uniform/#usage","text":"from baccarat import Simulator, UniformParam class DiceRollSimulator(Simulator): # Create a uniform parameter for dice rolls (1-6) # Note: We use 0.5 to 6.5 to get a uniform distribution over integers 1-6 roll = UniformParam(low=0.5, high=6.5) def simulation(self): # Get array of random dice rolls rolls = self.roll # Convert to integers (1-6) return np.floor(rolls).astype(int)","title":"Usage"},{"location":"tutorials/","text":"Tutorials Tutorial 1 - Approximating Pi","title":"Tutorials"},{"location":"tutorials/#tutorials","text":"Tutorial 1 - Approximating Pi","title":"Tutorials"},{"location":"tutorials/example1/","text":"Tutorial 1 - Approximating Pi Introduction This tutorial will guide you through the process of approximating the value of pi using a Monte Carlo simulation with the help of the baccarat library. The approximation we use is based on the ratio of the area of a circle to the area of a square that circumscribes it. If we generate random points within the square and count how many fall inside the circle, we can estimate the ratio of the areas and thus the value of pi! Step 1: Create a Simulator To begin, import the Simulator class from the baccarat module. from baccarat import Simulator The Simulator class is an abstract base class that provides the logic for running your Monte Carlo simulation. There are three primary methods that you need to know, but only one is an abstract method that you need to implement in your own simulator. The important methods are: simulation (abstract) compile_results run More details about these methods will follow as we complete the tutorial. Step 3: Implement the Simulator Since Simulator is an abstract base class, you need to create a subclass that inherits from Simulator where you will provide the implementation for the abstract method simulation . Let's call this class PiSimulator . When defining the class, we'll also define the parameters used in the simulation. To define the parameters, we'll add class attributes that are concrete instances of the the Param class. These concrete instances are actually descriptors that define a custom generate method. Accessing a parameter attribute on PiSimulator will return the value of that parameter's generate method as a NumPy array. Since these are NumPy arrays containing all the random values for the simulation at once, it is recommended to assign them to variables at the beginning of the simulation method for clarity and to enable vectorized operations. from baccarat import Simulator class PiSimulator(Simulator): radius = 1 # Not a parameter x = UniformParam(-radius, radius) y = UniformParam(-radius, radius) # This is a parameter, but could also be a constant value r = StaticParam(radius) def simulation(self): \"\"\"This is where we implement the logic for a single iteration of the simulation.\"\"\" # Get values from the parameters of the simulator x, y, r = self.x, self.y, self.r # Check if point falls inside the circle return x**2 + y**2 <= r**2 The return value of the simulation method is stored in a NumPy array: PiSimulator.results . This array contains the results from all simulation samples. By default, this array is returned when the simulation completes, at the end of the run method. Step 4: Implementing the compile_results Method Returning an array of results is all well and good, but if we're using the simulation to approximate pi, it seems like this would fall short of our goal and leave us with more work to do! Luckily, we can specify a custom implementation of the compile_results method to do some postprocessing to modify the return value appropriately. With vectorized operations, we can efficiently process all the simulation results at once. from baccarat import Simulator, UniformParam, StaticParam class PiSimulator(Simulator): radius = 1 # Not a parameter x = UniformParam(-radius, radius) y = UniformParam(-radius, radius) # This is a parameter, but could also be a constant value r = StaticParam(radius) def simulation(self): \"\"\"This is where we implement the logic for the simulation. The vectorized implementation processes all samples at once.\"\"\" # Get arrays of values from the parameters of the simulator x, y, r = self.x, self.y, self.r # Check if points fall inside the circle (returns boolean array) return x**2 + y**2 <= r**2 def compile_results(self): \"\"\"Do work on the collection of simulation results to compute the approximation of pi.\"\"\" # Apply the formula to compare the number of points inside the circle to the total number of points # and return the approximation of pi # Pi = 4 * A_circle / A_square return 4 * len([res for res in self.results if res]) / len(self.results) if __name__ == \"__main__\": num_sims = 1_000_000 simulator = PiSimulator(num_sims) result = simulator.run() # Will now return an approximation of pi! print(result) Conclusion In a handful of lines of code, we have a complete implementation of a Monte Carlo simulation to approximate the value of pi! The baccarat interface allowed us to separate the concerns of simulation logic and postprocessing and build our simulation incrementally. The implementation takes advantage of NumPy's vectorized operations to efficiently process all simulation samples at once. When parameters are accessed (like self.x ), they return NumPy arrays containing all the random values needed for the simulation. This vectorized approach provides substantial performance benefits compared to processing each sample individually in a loop.","title":"Tutorial 1 - Approximating Pi"},{"location":"tutorials/example1/#tutorial-1-approximating-pi","text":"","title":"Tutorial 1 - Approximating Pi"},{"location":"tutorials/example1/#introduction","text":"This tutorial will guide you through the process of approximating the value of pi using a Monte Carlo simulation with the help of the baccarat library. The approximation we use is based on the ratio of the area of a circle to the area of a square that circumscribes it. If we generate random points within the square and count how many fall inside the circle, we can estimate the ratio of the areas and thus the value of pi!","title":"Introduction"},{"location":"tutorials/example1/#step-1-create-a-simulator","text":"To begin, import the Simulator class from the baccarat module. from baccarat import Simulator The Simulator class is an abstract base class that provides the logic for running your Monte Carlo simulation. There are three primary methods that you need to know, but only one is an abstract method that you need to implement in your own simulator. The important methods are: simulation (abstract) compile_results run More details about these methods will follow as we complete the tutorial.","title":"Step 1: Create a Simulator"},{"location":"tutorials/example1/#step-3-implement-the-simulator","text":"Since Simulator is an abstract base class, you need to create a subclass that inherits from Simulator where you will provide the implementation for the abstract method simulation . Let's call this class PiSimulator . When defining the class, we'll also define the parameters used in the simulation. To define the parameters, we'll add class attributes that are concrete instances of the the Param class. These concrete instances are actually descriptors that define a custom generate method. Accessing a parameter attribute on PiSimulator will return the value of that parameter's generate method as a NumPy array. Since these are NumPy arrays containing all the random values for the simulation at once, it is recommended to assign them to variables at the beginning of the simulation method for clarity and to enable vectorized operations. from baccarat import Simulator class PiSimulator(Simulator): radius = 1 # Not a parameter x = UniformParam(-radius, radius) y = UniformParam(-radius, radius) # This is a parameter, but could also be a constant value r = StaticParam(radius) def simulation(self): \"\"\"This is where we implement the logic for a single iteration of the simulation.\"\"\" # Get values from the parameters of the simulator x, y, r = self.x, self.y, self.r # Check if point falls inside the circle return x**2 + y**2 <= r**2 The return value of the simulation method is stored in a NumPy array: PiSimulator.results . This array contains the results from all simulation samples. By default, this array is returned when the simulation completes, at the end of the run method.","title":"Step 3: Implement the Simulator"},{"location":"tutorials/example1/#step-4-implementing-the-compile_results-method","text":"Returning an array of results is all well and good, but if we're using the simulation to approximate pi, it seems like this would fall short of our goal and leave us with more work to do! Luckily, we can specify a custom implementation of the compile_results method to do some postprocessing to modify the return value appropriately. With vectorized operations, we can efficiently process all the simulation results at once. from baccarat import Simulator, UniformParam, StaticParam class PiSimulator(Simulator): radius = 1 # Not a parameter x = UniformParam(-radius, radius) y = UniformParam(-radius, radius) # This is a parameter, but could also be a constant value r = StaticParam(radius) def simulation(self): \"\"\"This is where we implement the logic for the simulation. The vectorized implementation processes all samples at once.\"\"\" # Get arrays of values from the parameters of the simulator x, y, r = self.x, self.y, self.r # Check if points fall inside the circle (returns boolean array) return x**2 + y**2 <= r**2 def compile_results(self): \"\"\"Do work on the collection of simulation results to compute the approximation of pi.\"\"\" # Apply the formula to compare the number of points inside the circle to the total number of points # and return the approximation of pi # Pi = 4 * A_circle / A_square return 4 * len([res for res in self.results if res]) / len(self.results) if __name__ == \"__main__\": num_sims = 1_000_000 simulator = PiSimulator(num_sims) result = simulator.run() # Will now return an approximation of pi! print(result)","title":"Step 4: Implementing the compile_results Method"},{"location":"tutorials/example1/#conclusion","text":"In a handful of lines of code, we have a complete implementation of a Monte Carlo simulation to approximate the value of pi! The baccarat interface allowed us to separate the concerns of simulation logic and postprocessing and build our simulation incrementally. The implementation takes advantage of NumPy's vectorized operations to efficiently process all simulation samples at once. When parameters are accessed (like self.x ), they return NumPy arrays containing all the random values needed for the simulation. This vectorized approach provides substantial performance benefits compared to processing each sample individually in a loop.","title":"Conclusion"}]}